{"name":"Evolution","tagline":"","body":"# Evolution\r\n\r\nMono.NET [![Build Status](https://travis-ci.org/bgarate/Evolution.svg?branch=master)](https://travis-ci.org/bgarate/Evolution)\r\n\r\nMicrosoft .NET [![Build status](https://ci.appveyor.com/api/projects/status/uhabegnl9qrlo2ma?svg=true)](https://ci.appveyor.com/project/bgarate/evolution) [![Coverage Status](https://coveralls.io/repos/github/bgarate/Evolution/badge.svg?branch=master)](https://coveralls.io/github/bgarate/Evolution?branch=master)\r\n\r\n## What is Singular.Evolution?\r\n\r\nSingular.Evolution or simply Evolution is an Evolutionary Computation Framework written in C# compatible with Microsoft .NET(3.5 and up) and Mono. It was designed to be flexible and powerful. It offers a declarative style interface and modern design patterns.\r\n\r\n## Architecture\r\n\r\n### Engine\r\n\r\nThe engine is responsible for providing the runtime environment. After the algorithm has been defined, the engine runs and keeps the state of the evolution.\r\n\r\n### Algorithm\r\n\r\nThe algorithm knows all the steps that must be taken place in each epoch or generation. Before building the `Engine`, an `Algorithm` must be defined. At the moment, only `EasyGa`, a basic genetic algorithm has been implemented. To create a custom one, `IAlgorithm` can be implemented or `EasyGa` can be inherited.\r\n\r\n### Genes and Genotypes\r\n\r\nGenes (which implement `IGene`) are the basic information blocks processed by the `Algorithm`. All the genes of an `Individual` form a `Genotype`. There exist multiple already implemented `Gene` types:\r\n\r\n* Numeric genes. They wrap another type (generally a primitive type) and provide basic arithmetic operations\r\n * `FloatGene`: They store a `double` value. They can be optionally *bounded*, *minimum* and *maximum* values can be defined for its value.\r\n * `BitGene`: They store a boolean value.\r\n* `EnumGene`: They wrap an `Enum`.\r\n\r\nGenotypes implement the `IGenotype` interface. By now only the `ListGenotype` genotype is provided as an implementation of the `IListGenotype` interface. In it, genes are arranged in a constant size list.\r\n\r\n### Fitness and Individuals\r\n\r\nWhen declaring the engine any type `F` that implements `IComparable<F>` can hold the fitness value for the individuals. `Individuals` have a `Genotype` and can be assigned a `Fitness`.\r\n\r\n### World\r\n\r\nWorld represents the state of the population of individuals in a particular generation. The engine returns a `World` anytime a step (generation or epoch) of the algorithm is run.\r\n\r\n### Selectors, Alterers and Breeders\r\n\r\nThe algorithm makes use of this three elements to initialize, modify and return a new population. An `Alterer`, given a pool of individuals, returns a new set. A `Selector` selects some individuals from a population. In fact, a `Selector` can be seen as an alterer that doesn't change the individuals. `Breeders` provide a way to get the starting population for the algorithm.\r\n\r\n## Example\r\n(Code is written on C# 6)\r\n\r\nThis is a simple example in which genotypes are a collection of `BitGene` and the `Fitness` of an Individual is seen as the number of BitGenes with value true.\r\n\r\n````c#\r\npublic void EasyGaTest()\r\n  {\r\n    // Crossover with one cut ppoin \r\n    var crossover = new MultipointCrossover<ListGenotype<BitGene>, BitGene, double>(1);\r\n\r\n    var algorithm =\r\n    new EasyGa<ListGenotype<BitGene>, double>.Builder()\r\n          .WithElitismPercentage(0.5)             // Best 50% of previous population remains\r\n          .WithFitnessFunction(g => ((ListGenotype<BitGene>) g).Count(b => b.Value))  // Fitness is # of Genes with value 'true'\r\n          .WithStopCriteria(w => w.Generation > 2500 || w.BestFitness == 20) // Stop if I reach a Genotype full of genes with value 'true'\r\n                                                                            // or generation 2501\r\n          .RegisterBreeder(new BitBreeder(20,20))         // Start with 20 individuals with 20 BitGenes\r\n          .Register(new RouletteWheelSelector<ListGenotype<BitGene>>(20)) // Select 20 individuals with RouletteWheelSelector (Fitness Proportionate Selection)\r\n          .Register(new Recombinator<ListGenotype<BitGene>, double>(crossover, 2, 10)) // Apply the crossover operation 10 times taking two parents each time\r\n          .Register(new BitMutator<ListGenotype<BitGene>, double>(0.05)) // Mutation with a 5% probability over all population's genes\r\n          .Build(); // Build the algorithm\r\n\r\n    var engine = new Engine<ListGenotype<BitGene>, double>.Builder()\r\n          .WithAlgorithm(algorithm)\r\n          .Build(); // Build the engine\r\n\r\n    while (!engine.HasReachedStopCriteria) // Run until the stop criteria is met\r\n    {\r\n      engine.NextGeneration(); // Run the next generation\r\n    }\r\n\r\n    Debug.WriteLine($\"{engine.World.Generation} generations reached\");\r\n    Debug.WriteLine($\"{engine.World.BestFitness} is best Fitness\");\r\n    Debug.WriteLine($\"{engine.World.BestGenotype} is best Genotype\");\r\n\r\n  }\r\n````\r\n\r\nAn example output would be:\r\n\r\n> &nbsp;</br>\r\n> 24 generations reached</br>\r\n> 20 is best Fitness</br>\r\n> 1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1 is best Genotype</br>\r\n> &nbsp;\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}